## 变量的定义
基本形式： 类型说明符（type specifier）, 随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后分号结束。
```cpp
int sum = 0, value, // sum,value 和units_sold 都是 int
units_sold = 0; // sum 和 units_sold 初始值为0
Sales_item item; // item 的类型是 Sales_item 
// string 是一种库类型，表示一个可变长的字符序列
std::string book("0-201-78345-X"); 
// book 通过一个string字面值初始化
```
* 初始化并不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
### 列表初始化

### 默认初始化
    如果定义变量是没有指定初始值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

## 变量声明
* 声明变量而非定义，在变量名前添加关键字 extern, 而且不要显式地初始化变量
```cpp
extern int i; // 声明i 而非定义i
int j; // 声明并定义j
```

## 静态类型

C++ 是一种静态类型(statically typed)语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查( type checking )

对象的类型决定了对象所能参与的运算，在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。

程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型

## 复合类型
    复合类型(compound type) 是指基于其他类型定义的类型。C++语言有几种复合类型。
### 引用和指针
一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。
* 引用
引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将什么符写成`&d`的形式来定义引用类型，其中d是声明的变量名：

```cpp
int ival = 1024;
int &refval = ival; // refVal 指向 ival
int &refVal2; // 报错： 引用必须内初始化
```

一般在初始化变量时，初始值会被拷贝带新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

## 指针
 指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须再定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

 定义指针类型的方法将声明符写成 `*d` 的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*：

 ```cpp
 int *ip1, *ip2; // ip1 和 ip2 都是指向int型对象的指针
 double db, *dp2 // dp2 是指向double型对象的指针，db是double型对象
 ```

 ### 获取对象的地址
 指针存放某个对象的地址，要想获取该地址，需要使用 取地址符（操作符&）：
 ```cpp
 int ival = 42;
 int *p = &ival; // p存放变量ival的地址，或者说p是指向变量ival的指针
 ```
  两种例外情况
  ```cpp
  double dval;
  double *pd = &dval; // 正确：初始值是double型对象的地址
  double *pd2 = pd; // 正确：初始值是指向double对象的指针

  int *pi = pd; // 错误： 指针pi的类型和pd的类型不匹配
  pi = &dval; // 错误：试图把double型对象的地址赋值给int型指针
  ```
  因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

  ### 指针值
    指针的值（即地址）应属下列4种状态之一
* 指向一个对象
* 指向邻近对象所占用空间的下一个位置
* 空指针，意味着指针没有指向任何对象
* 无效指针，也就是上述情况之外的其他值。
试图拷贝或以其他方式访问无效指针的值都将引发错误

### 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象:
```cpp
int ival = 42;
int *p = &ival; // p 存放着变量ival的地址，或者说p是指向变量ival的指针
cout<< *p; // 由符号*得到指针p所指的对象，输出42
```
对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：
```cpp
*p = 0 // 由符号* 得到指针p所所指的对象，即可有p为变量ival赋值
cout << *p // 输出0
```
* 解引用操作仅适用于那些确实指向了某个对象的有效指针

### 某些符号有多重含义
像& 和* 这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：
```cpp
int i = 42;
int &r = i; // &紧随类型名出现，因此是声明的一部分，r是一个引用
int *p; // * 紧随类型名出现，因此是声明的一部分，p是一个指针
p = &i; // & 出现在表达式中，是一个取地址符
*p = i; // * 出现在表达式中，是一个解引用
int &r2 = *p; // &是声明的一部分， * 是一个解引用
```

### 空指针
空指针(null pointer) 不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法
```cpp
int *p1 = nullptr; // 等价于 int *p1 = 0
int *p2 = 0;// 直接将p2初始化字面常量 0
// 需要首先#include cstdlib
int *p3 = NULL； 
```
得到空指针最直接的办法就是用字面量值`nullptr`来初始化指针，nullptr是一种特殊类型的字面量，它可以被转换成任意其他指针类型。另外一种办法就如p2的定义一样，也可以通过将指针初始化字面值0 来生成空指针

把int 变量直接赋值给指针是错误的操作，及时int 变量的值恰好等于0也不行
```cpp
int zero = 0;
pi = zero; // 错误：不能把int变量直接赋值给指针
```
### 赋值和指针
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用就是它最初绑定的对象

## 复合类型的声明

变量的定义包括一个基本数据类型（base type） 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量：
```cpp
// i 是一个int型的数，p是一个int型指针，r是一个int型引用
int i =1024, *p = &i, &r = i;
```
定义多个变量
* 指向指针的指针
一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。

通过*的个数可以区分指针的级别。也就是说，** 表示指向指针的指针，***表示指向指针的指针的指针，一次类推：
```cpp
int ival = 1024;
int *pi = &ival; // pi 指向一个int型的数
int **ppi = &pi; // ppi 指向一个int型的指针
```

* 指向指针的引用
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：
```cpp
int i =42;
int *p; // p是一个int 型指针
int *&r = p; // r 是一个对指针p的引用

r = &i; // r引用了一个指针，因此给r 赋值&i就是令p指向i
*r = 0; // 借引用r得到 i，也就是p指向的对象，将i的值变为 0
```